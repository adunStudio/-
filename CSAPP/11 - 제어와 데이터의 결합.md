# 제어와 데이터의 결합

제어와 데이터가 상호작용하는 방식을 살펴보자.

## 범위를 벗어난 메모리 참조와 버퍼 오버플로우

지역변수들은 스택에 보존용 레지스터들과 리턴 주소 같은 상태정보와 함께 스택에 저장된다. 스택에 저장된 상태정보가 범위를 벗어난 배열의 원소에 대한 쓰기 작업에 의해 변경된 후 프로그램이 레지스터값을 적재하거나 이렇게 변경된 상태정보를 사용해서 `ret` 인스트럭션을 실행하면 심각한 프로그램 에러가 발생할 수 있다.

일반적인 상태 손실의 원인은 **버퍼 오버플로우**(buffer overflow)로 알려져 있다. 예를 들어, 어떤 문자배열이 스택에 스트링을 가지고 할당되어 있지만, 스트링의 크기는 배열에 할당된 공간을 초과하면 버퍼 오버플로우가 발생한다.

```cpp
/* Implementation of library function gets() */
// 표준 입력으로부터 한 주을 읽어들이고 엔터 키나 오류 상황이 발생했을 때 멈추는 함수
// 스트링을 인자 s라는 위치에 복사하고, 스트링의 마지막에 널 문자를 추가한다.
char* gets(char* s)
{
    int c;
    char* dest = s;
    
    while((c = getchar()) != '\n' && c != EOF)
        *dest++ = c;
    
    if(c == EOF && dest == s)
        /* No characterts read */
        return NULL;
    
    *dest++ = '\0'; /* Terminsate string */
    return s;
}

void echo()
{
    char buf[8]; /* too small! */
    gets(buf);
    puts(buf);
}
```

gets() 함수의 문제는 전체 스트링을 저장할 수 있는 공간이 충분히 할당되었는지 결정할 방법이 없다는 것이다. 위 예제에서 길이가 7바이트보다 더 긴 스트링들은 모두 범위초과 쓰기를 발생시킨다.

```assembly
// void echo()
echo:
	subq	$24, %rsp	// Allocate 24 bytes on stack
	movq	%rsp, %rdi  // Compute buf as %rsp
	call 	gets		// Call gets
	movq	%rsp, %rdi	// Compute buf as %rsp
	call	puts		// Call puts
	addq	$24, %rsp	// Deallocate stack space
	ret					// Return
```

위 어셈블리 코드는 echo를 실행하는 동안에 스택의 구성을 보여준다. 프로그램은 스택 포인터에서 24를 빼서 스택에 24 바이트를 할당한다. gets와 puts 호출 시에 인자로 사용하기 위해 `%rsp`가 `%rdi`로 복사된다는 사실로 알 수 있는 것처럼 문자 buf는 스택의 탑에 위치한다. buf와 저장된 리턴주소 사이의 16바이트는 사용되지 않는다. 사용자가 최대 7문자 이상을 입력한다면, gets는 스택에 저장된 정보 일부를 덮어쓰게 된다.

| Characters typed | Additional corrupted state |
| ---------------- | -------------------------- |
| 0 - 7            | None                       |
| 9 - 23           | Unused stack space         |
| 24 - 31          | Return address             |
| 32+              | Saved state in caller      |

23개의 문자 스트링까지는 심각한 결과가 발생하지 않지만, 이 이상의 경우 리턴주소의 값과 저장된 상태까지도 손상될 것이다. 만일 리턴주소의 값이 손상되면, `ret` 인스트럭션은 프로그램을 전혀 예상하지 못한 곳으로 점프하게 할 것이다. 이와 같은 범위 초과 메모리 쓰기의 충격은 프로그램을 기계어 수준에서 공부해야 할 수 있는 내용이다.

버퍼 오버플로우가 치명적인 이유 중 하나는 프로그램이 하지 않는 기능들을 실행하는 것이다. 이를 통해 컴퓨터 네트워크상의 시스템 보안성을 공격할 수 있다. **탐색코드**(exploit-code)라고 실행코드를 가리키는 포인터로 리턴주소를 덮어쓴 후, `ret` 인스트럭션을 실행하면 탐색코드로 점프하게 된다.

탐색코드는 시스템 콜을 이용해서 쉘 프로그램을 시작하고, 공격자에게 여러 가지 운영체제 기능을 제공한다. 즉, 탐색코드는 허용되지 않은 기능을 실행한다.

---

## 버퍼 오버플로우 공격 대응 기법

최신 컴파일러와 운영체제는 버퍼 오버플로우 공격을 통해서 시스템의 제어권을 획득할 수 있는 방법을 제한하는 방법을 구현한다. 리눅스 GCC에서 제공하는 기법을 살펴보자.

### 스택 랜덤화

탐색코드를 시스템에 삽입하려면 공격 스트링에 코드뿐만 아니라 코드로의 포인터까지 집어넣어야 한다. 이 포인터를 만들기 위해서는 스트링이 위치하게 될 스택의 주소를 알아야 한다.

**스택 랜덤화**는 스택의 위치를 프로그램의 매 실행마다 다르게 해주는 것이다. 그래서 컴퓨터들이 같은 코드를 실행해도, 완전히 다른 스택의 주소를 사용하게 된다. 예를 들어 프로그램의 시작 시 스택에 `alloca` 함수를 사용해서 0부터 n 바이트 사이의 랜덤 크기 공간을 할당해서 스택에 정해진 크기의 공간을 할당한다. 이렇게 할당된 공간은 프로그램에서 사용하지 않지만, 이렇게 함으로써 프로그램의 매 실행마다 모든 이후의 스택 위치가 변경되도록 해준다. n의 범위는 너무 커서 공간을 낭비하지 않아야 하며, 스택 주소에 충분한 변화를 줄 정도로 큰 값을 유지해야 한다.

### 스택 손상 검출

두 번째 방어 방법은 스택이 손상되는 것을 감지하는 것이다. **스택 보호 코드**를 버퍼 오버플로우를 감지하기 위해 생성된 코드에 추가하는 기법이다. 이 방법은 지역 버퍼와 나머지 스택 상태 값 사이에 **카나리**(canary)값을 저장하는 것이다. 이 카나리 값은 **보호값**(guard value)라고도 불리며, 프로그램의 매 실행마다 랜덤으로 생성되므로 공격자가 값을 쉽게 추정하기 어렵다. 레지스터 상태를 복원하고 함수로부터 리턴하기 전에 프로그램은 카나리 값이 이 함수나 호출한 함수의 동작에 의해 변경되었는지 체크해서, 변경되었다면 프로그램은 에러를 발생시키면서 종료한다.

### 실행코드 영역 제한하기

마지막 방법은 공격자가 실행코드를 시스템에 추가할 가능성을 제거하는 것이다. 한 가지 방법은 어느 메모리 영역이 실행코드를 저장할지를 제한하는 것이다. 한 가지 방법은 어느 메모리 영역이 실행코드를 저장할지를 제한하는 것이다. 일반적인 프로그램에서는 컴파일러가 만든 코드를 저장하는 메모리 부분만 실행 가능하면 되므로 다른 부분들은 읽기와 쓰기만 허용하도록 제한하는 것이다.

지금까지 설명한 방법들(랜덤화, 스택보호, 실행 코드를 저장할 수 있는 메모리 부분을 제한하기)은 프로그래머에게 요구하는 것이 없으면서 성능을 거의 감소시키지 않는 버퍼 오버플로우 취약성을 최소화하기 위해 사용되는 일반적인 기법이다.

---

## 가변크기 스택 프레임

할당되어야 하는 스택 프레임의 크기를 컴파일러가 미리 결정한다. 그러나 일부 프로시저들은 가변적인 지역저장공간 크기를 필요로 한다. 이런 경우는 프로시저가 스택에 임의의 크기의 바이트를 할당하는 표준함수인 `alloca`를 호출할 때 일어난다.

```cpp
// C code
long vframe(long n, long idx, long* q)
{
    long i;
    long* p[n];
    p[0] = &i;
    for(i = 1; i < n; i++)
        p[i] = q;
    return *p[idx];
}
```

위 예제 코드는 가변크기 배열을 포함하는 함수의 예다. 이 프로그램은 지역변수 *i*에 대한 주소를 참조를 생성하므로 이 변수는 스택에 저장되어야 한다. 이 함수는 *n*개의 포인터들의 지역배열 p를 선언하며, *n*의 값은 함수의 호출 때마다 달라지므로 컴파일러는 얼마만큼의 공간이 함수의 스택 프레임을 위해 할당되어야 하는지 결정할 수 없다.

```assembly
// Portions of generated assembly code
// long n in %rdi, inx in %rsi, q in %rdx
// Only portions of code shown
vframe:
	pushq	%rbp				// Save old %rbp
	movq	%rsp, %rbp			// Set base pointer
	subq	$16, %rsp			// Allocate space for i        (1)
	leaq 	22(, %rdi, 8), %rax
	andq	$-16, %rax
	subq	%rax, %rsp			// Allocate space for array p  (2)
	leaq	%7(%rsp), %rax
	shrq	$3, %rax
	leaq	0(, %rax, 8), %r8	// Set %r8 to &p[0]
	movq	%r8, %rcx			// Set %rcx to &p[0]
	// ...
// Code for initialization loop
// i in %rax and on stack, n in %rdi, p in %rcx, q in %rdx
  .L3:
  	movq	%rdx, (%rcx,%rax, 8)// Set p[i] to q
  	addq	$1, %rax			// Increament i
  	movq	%rax, -8(%rbp)		// Store on stack
  .L2:
  	movq	-8(%rbp), &rax		// Retrieve i from stack
  	cmpq	%rdi, %rax			// Compare i:n
  	j1		.L3					// if <, goto loop
  	// ...
// Code for function exit
	leave						// Restore %rbp and %rsp
	ret							// Return
```

가변크기 스택 프레임을 처리하기 위해 x86-64 코드는 레지스터 `%rbp`를 이용해서 **베이스 포인터**(base pointer)로 사용한다. `%rbp` 레지스터는 callee-saved 레지스터이므로 스택에 이전 버전의 `%rbp`를 보관한다. 그 후 함수가 실행되는 동안 계속 `%rbp`를 현 위치를 가리키도록 유지하며, 이것은 고정 길이 지역 변수들(ex. *i*)을 `%rbp`에 대한 상대적인 오프셋 값으로 참조한다.

위 코드에서 16바이트를 스택에 할당하는데, 첫 8바이트는 지역변수 *i*를 저장하는 데 사용하며, 두 번째 8바이트는 사용하지 않는다. 그리고 나서, 배열 *p*를 위한 공간을 할당한다.

배열 *p*는 (1) 에서 스택에 최소 8*n* 바이트를 할당하였으며, (2) 할당된 영역 내에 배열 *p*를 배치하였으므로 최소 8*n* 바이트가 사용할 수 있다.

초기화 루프 코드에서 *i*의 주소는 베이스 포인터에 상대적으로 오프셋 -8 떨어져 있으므로 `-8(%rbp)`를 통해 참조한다.

프레임 포인터는 함수의 끝에서 `leave` 인스트럭션을 이용해서 자신의 이전 값으로 복원된다. 이 인스트럭션을 인자를 하나도 갖지 않으며, 다음 두 인스트럭션을 실행하는 것과 같다:

```assembly
movq	%rbp, %rsp	// Set stack pointer to beginning of frame
popq	%rbp		// Restore save %rbp ans set stack ptr to end of caller's fame
```

즉, 스택 포인터는 `%rbp` 값이되고, 그 후 `%rbp`는 스택에서 이전 값이 팝 된다. 그러므로 전체 스택 프레임을 반환하는 효과를 낸다.

---