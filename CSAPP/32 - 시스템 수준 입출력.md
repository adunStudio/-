# 시스템 수준 입출력

입출력(I/O)은 메인 메모리와 디스크 드라이브, 터미널, 네트워크 같은 외부 장치 간에 데이터를 복사하는 작업이다. 입력 연산은 입출력 장치에서 메인 메모리로 데이터를 복사하고, 출력 연산은 데이터를 메모리에서 디바이스로 복사한다.

모든 언어의 런타임 시스템은 입출력을 수행하기 위한 고급 기능들을 제공한다. 예를 들어, ANSI C는 버퍼를 이용해서 I/O를 수행하는 `print`와 `scanf` 같은 함수들을 표준 I/O 라이브러리에서 제공한다. 리눅스 시스템에서, 이러한 고급 I/O 함수들은 커널이 제공하는 시스템 수준 Unix I/O 함수들을 사용해서 구현되어 있다.

여기에서는 Unix I/O와 표준 I/O의 일반전인 개념을 소개하고, C 프로그램에서 이들을 어떻게 안정적으로 사용하는지에 대해 설명한다.

---

## 1. Unix I/O

리눅스에서 **파일**은 연속된 *m*개의 바이트다:

$B_0, B_1, …, B_k, …, B_{m-1}​$

네트워크, 디스크, 터미널 같은 모든 I/O 디바이스들은 파일로 모델링되며, 모든 입력과 출력은 해당 파일을 읽거나 쓰는 형식으로 수행된다. 이처럼 리눅스 커널은 디바이스에서 파일로 매핑하므로 **Unix I/O**라고 하는 간단한 저급 응용 인터페이스를 제공할 수 있게 되었으며, 이들은 모든 입력과 출력이 일정하고 통일된 방식으로 수행되도록 해준다.

- **파일 열기**: 응용 프로그램은 I/O 디바이스에 접근하겠다는 의도를 해당 파일을 열겠다고 커널에 요청하는 방법으로 알린다. 커널은 **식별자(descriptor)**라고 하는 음수가 아닌 작은 정수를 리턴하며, 이것은 이후의 파일에 관한 모든 연산에서 이 파일을 나타낸다. 커널은 열린 파일에 관한 모든 정보를 추적하고, 응용 프로그램은 식별자만 추적한다.
  - 표준 입력(식별자 0): STDIN_FILENO
  - 표준 출력(식별자 1): STDOUT_FILENO
  - 표준 에러(식별자 2): STDERR_FILENO
- **현재 파일 위치의 변경**: 커널은 파일을 열 때마다 *파일 위치 k*를 관리하며, 이것은 처음에는 0이다. 파일 위치는 파일의 시작 부분에서부터 바이트 오프셋이다. 응용 프로그램은 *seek* 연산을 수행해서 현재의 파일 위치를 명시적으로 설정할 수 있다.
- **파일 읽기와 쓰기**: **읽기** 연산은 현재 파일 위치 *k*에서 시작해서 *n* > 0 바이트를 파일에서 메모리로 복사하고, *k*를 *n* 증가시킨다. 크기가 *m*바이트인 파일이 주어졌을 때, *k*>=*m*인 읽기 연산을 수행하면 *end-of-file* EOF라고 알려진 조건이 발생하며, 이것은 응용 프로그램에서 감지할 수 있다. 실제 파일의 끝에서 "EOF 문자"가 명시적으로 존재하는 것은 아니다. 마찬가지로, **쓰기** 연산은 현재 파일 위치 *k*에서 시작해서 *n* > 0 바이트를 메모리에서 파일로 복사하고, *k*를 갱신한다.
- **파일 닫기**: 응용 프로그램이 파일 접근을 끝마치면, 커널에 파일을 **닫아**줄 것을 요청한다. 커널은 파일을 열었을 때 만든 자료구조들을 반환하는 것으로 대응하며, 식별자를 가용 식별자 풀로 복원한다. 프로세스가 어떤 이유에서든 종료할 때, 커널은 모든 열려 있는 파일들을 닫고, 이들의 메모리 자원을 반환한다.

---

## 2, 파일

각각의 리눅스 파일은 시스템에서의 역할을 나타내는 타입을 가진다:

- **일반 파일**: 임의의 데이터를 포함한다. ASCII 문자나 유니코드만을 포함하는 *텍스트 파일*과 그 외의 모든 파일을 포함하는 *이진 파일* 로구분한다. 커널에게는 파일 간에 차이가 없다. 리눅스 텍스트 파일은 *텍스트 라인*들로 구성되며, 각각의 라인은 *새 줄* 문자 ('\n')으로 종료된다.
- **디렉토리**: *링크*들의 배열로 구성되며, 각각의 링크는 *파일 이름*을 파일로 대응시키거나 또 다른 디렉토리일 수 있다.
- **소켓**: 네트워크상의 다른 프로세스와 통신하기 위해 사용되는 파일이다.

---

## 3. 파일 열기와 닫기

프로세스는 다음과 같은 `open` 함수를 호출해서 기존의 파일을 열거나 새 파일을 생성한다:

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(char* filename, int flags, mode_t mode);
// Returns: new file descriptor if OK, -1 on error
```

`open` 함수는 *filename*을 파일 식별자로 변환하고 식별자 번호를 리턴한다. 리턴된 식별자는 항상 프로세스 내에서 현재 열려 있지 않은 가장 작은 식별자다. *flags* 인자는 어떻게 프로세스가 파일에 접근하는지를 나타낸다. *mode* 인자는 새 파일들의 접근 권한 비트들을 명시한다.

마지막으로, 프로세스는 오픈한 파일을 `close` 함수를 호출해서 닫는다.

```cpp
#include <unistd.h>

int close(int fd);
// Returns: 0 if OK, -1 on error
```

이미 닫은 파일 식별자를 닫게 되면 에러가 발생한다.

---

## 4. 파일 읽기와 쓰기

응용 프로그램은 `read`와 `write` 함수를 호출해서 읽기와 쓰기를 수행한다.

```cpp
#include <unistd.h>

ssize_t read(int fd, void* buf, size_t n);
// Returns: number of bytes read if OK, 0 on EOF, -1 on error

ssize_t write(int fd, const void* buf, size_t n);
// Returns: number of bytes written if OK, -1 on error
```

`read` 함수는 식별자 *fd*의 현재 파일 위치에서 최대 *n* 바이트를 메모리 위치 *buf*로 복사한다. 반대로, `write` 함수는 메모리 위치 *buf*에서 식별자 *fd*의 현재 파일 위치로 최대 *n* 바이트를 복사한다.

---