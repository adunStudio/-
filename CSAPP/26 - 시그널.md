# 시그널

**시그널**은 작은 메시지 형태로, 프로세스에게 시스템 내에 어떤 종류의 이벤트가 일어났다는 것을 알려준다.

각 시그널 타입은 특정 종류의 시스템 이벤트에 대응된다. 예를 들어, 어떤 프로세스가 0으로 나누려고 하면 커널은 SIGFPE 시그널(8번)을 프로세스에 보낸다. 

## 1. 시그널 용어

시그널을 목적지 프로세스로 전달하는 것은 두 단계로 이루어진다:

- **시그널 보내기** : 커널은 목적지 프로세스의 컨텍스트 내에 있는 일부 상태를 갱신해서 시그널을 목적지 프로세스로 보낸다. 다음 두 가지 이유 중의 하나로 배달된다:
  - 커널이 0으로 나누기나 자식 프로세스의 종료 같은 시스템 이벤트를 감지했다.
  - 어떤 프로세스가 커널에 명시적으로 시그널을 목적지 프로세스에 보낼 것을 요구하기 위해서 `kill` 함수를 호출했다. (프로세스는 시그널을 자기 자신에게 보낼 수 있다.)

- **시그널 받기** : 목적지 프로세스는 배달된 신호에 대해서 커널이 어떤 방식으로 반응해야 할 때 목적지 프로세스는 시그널을 받는다. 프로세스는 **시그널 핸들러**라고 부르는 사용자수준 함수를 실행해서 시그널을 무시하거나, 종료하거나 획득할 수 있다.

---

## 2. 시그널 보내기

Unix 시스템은 시그널을 프로세스로 보내는 여러 가지 메커니즘을 제공한다. 모든 메커니즘은 **프로세스 그룹** 개념을 사용한다.

### 프로세스 그룹

모든 프로세스는 정확히 한 개의 **프로세스 그룹**에 속하며, 이것은 양수 *process group* ID로 식별한다.

`getpgrp` 함수는 현재 프로세스의 프로세스 그룹 ID를 리턴한다:

```cpp
#include <unistd.h>

pid_t getpgrp(void);	// Returns: process group ID of calling process
```

기본적으로, 자식 프로세스는 자신의 부모와 같은 프로세스 그룹에 속한다. 프로세스는 자신의 프로세스 그룹 또는 다른 프로세스의 그룹을 `setpgid` 함수를 사용해서 변경할 수 있다:

```cpp
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);	// Returns: 0 on success, -1 on error
```

`setpgid` 함수는 프로세스 pid의 프로세스 그룹을 pgid로 변겨한다. 만일 pid가 0이면 현재 프로세스의 PID가 사용된다. 만일 pgid가 0이면 pid로 명시된 프로세스의 PID가 프로세스 그룹 ID로 사용된다. 예를 들어, 프로세스 15213이 호출하는 프로세스라면 `setpgid(0, 0)`은 프로세스 그룹 ID가 15213인 새로운 프로세스 그룹을 만들고, 프로세스 15213을 새 그룹에 추가한다.

### kill함수로 시그널 보내기

프로세스는 `kill` 함수를 호출해서 시그널을 다른 프로세스로 보낸다(자기 자신을 포함해서).

```cpp
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);	// Returns: 0 if OK, -1 on error
```

만일 pid가 0보다 크면, `kill` 함수는 시그널 번호 sig를 프로세스 pid로 보낸다. 만일 pid가 0이면 kill은 호출하는 프로세스인 자신을 포함해서 프로세스 그룹 내 모든 프로세스에 시그널 sig를 보낸다.

### 키보드에서 시그널 보내기

쉘은 각 작업마다 별도의 프로세스 그룹을 만든다. 최대 한 개의 포그라운드 작업(job)과 0개 이상의 백그라운드 작업이 존재할 수 있다. 키보드에서 Ctrl+C를 입력해서 포그라운드 프로세스 그룹에 속한 모든 프로세스에 SIGINT 시그널을 보낼 수 있다. 결과적으로 포그라운드 작업은 종료된다.

---

## 3. 시그널의 수신

보내졌지만 아직 받지 않은 시그널을 **펜딩(pending) 시그널**이라고 한다. 커널이 프로세스 *p*를 커널 모드에서 사용자 모드로 전환할 때, 커널은 프로세스 *p*에 대한 블록되지 않은 펜딩 시그널의 집합을 체크한다. 만일 이 지합이 비어 있다면, 커널은 제어를 *p*의 논리 제어흐름 내의 다음 인스트럭션($I_{next}​$)으로 전달한다.

그렇지 않다면, 커널은 집합 내 어떤 시그널 *k*를 선택해서 *p*가 시그널 *k*를 수신하도록 한다. 시그널을 수신하면 프로세스는 어떤 동작을 개시한다. 동작이 완료하면, 제어는 *p*의 논리 제어흐름 내의 다음 인스트럭션($I_{next}$)으로 돌아간다. 각 시그널 타입의 동작은 다음 중 하나다:

- 프로세스가 종료한다.
- 프로세스는 종료하고 코어를 덤프한다.
- 프로세스는 SIGCONT 시그널에 의해 재시작될 때까지 정지한다.
- 프로세스는 시그널을 무시한다.

프로세스는 시그널과 연결된 기본 동작을 `signal` 함수를 사용해서 수정할 수 있다. (예외: SIGSTOP, SIGKILL)

```cpp
#include <signal.h>
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
// Returns pointer to previous hanlder if OK, SIG_ERR on error
```

어떤 프로세스가 타입 *k*의 시그널을 잡을 때, 시그널 *k*를 위해 설치된 핸들러는 *k*에 설정된 한 개의 정수 인자를 사용해서 호출한다. 이 인자는 핸들러 함수가 서로 다른 종류의 시그널을 잡을 수 있도록 해준다.

---